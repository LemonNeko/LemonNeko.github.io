<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.lemonneko.cn","root":"/","scheme":"Gemini","version":"8.0.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="依赖注入 依赖注入的动机就是减少组件之间的耦合度，使开发更为简洁 依赖注入能够独立开发各组件，然后根据组件间关系进行组装 依赖注入提供使用接口编程 依赖注入只对象在使用时动态注入">
<meta property="og:type" content="article">
<meta property="og:title" content="牛客网刷题笔记 ——Java">
<meta property="og:url" content="https://www.lemonneko.cn/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Java/index.html">
<meta property="og:site_name" content="LemonNeko的博客">
<meta property="og:description" content="依赖注入 依赖注入的动机就是减少组件之间的耦合度，使开发更为简洁 依赖注入能够独立开发各组件，然后根据组件间关系进行组装 依赖注入提供使用接口编程 依赖注入只对象在使用时动态注入">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lemonneko-1253391789.cos.ap-shanghai.myqcloud.com/hexo/TheProblemSovingNotesBasedNowcoder/CollectionsFramework.gif">
<meta property="og:image" content="https://lemonneko-1253391789.cos.ap-shanghai.myqcloud.com/hexo/TheProblemSovingNotesBasedNowcoder/DataTypeAndInitialValue.png">
<meta property="og:image" content="https://lemonneko-1253391789.cos.ap-shanghai.myqcloud.com/hexo/TheProblemSovingNotesBasedNowcoder/InnerClass.png">
<meta property="og:image" content="https://lemonneko-1253391789.cos.ap-shanghai.myqcloud.com/hexo/TheProblemSovingNotesBasedNowcoder/Servlet.png">
<meta property="og:image" content="https://lemonneko-1253391789.cos.ap-shanghai.myqcloud.com/hexo/TheProblemSovingNotesBasedNowcoder/Servlet2.jpg">
<meta property="og:image" content="https://lemonneko-1253391789.cos.ap-shanghai.myqcloud.com/hexo%E5%AD%98%E5%82%A8/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Java/socket.png">
<meta property="og:image" content="https://lemonneko-1253391789.cos.ap-shanghai.myqcloud.com/hexo/TheProblemSovingNotesBasedNowcoder/No6Result.png">
<meta property="article:published_time" content="2019-03-09T17:02:08.000Z">
<meta property="article:modified_time" content="2020-08-26T15:24:27.272Z">
<meta property="article:author" content="LemonNeko">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lemonneko-1253391789.cos.ap-shanghai.myqcloud.com/hexo/TheProblemSovingNotesBasedNowcoder/CollectionsFramework.gif">


<link rel="canonical" href="https://www.lemonneko.cn/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Java/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>牛客网刷题笔记 ——Java | LemonNeko的博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?85658a99d7ed12e83a772603fd823a67";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LemonNeko的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">www.lemonneko.cn</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-number">1.</span> <span class="nav-text">依赖注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection%E4%B8%8EMap"><span class="nav-number">3.</span> <span class="nav-text">Collection 与 Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E3%80%81HashTable%E5%92%8CtreeMap"><span class="nav-number">4.</span> <span class="nav-text">HashMap、HashTable 和 treeMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-number">5.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">6.</span> <span class="nav-text">volatile 关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized%E4%B8%8Evolatile"><span class="nav-number">7.</span> <span class="nav-text">synchronized 与 volatile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">8.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-number">9.</span> <span class="nav-text">运行时数据区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">10.</span> <span class="nav-text">静态变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC"><span class="nav-number">11.</span> <span class="nav-text">GC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98"><span class="nav-number">11.1.</span> <span class="nav-text">堆内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="nav-number">12.</span> <span class="nav-text">Java 编译和运行命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exe"><span class="nav-number">12.1.</span> <span class="nav-text">.exe</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#substring"><span class="nav-number">13.</span> <span class="nav-text">substring</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch"><span class="nav-number">14.</span> <span class="nav-text">switch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#try%E2%80%A6catch-finally"><span class="nav-number">15.</span> <span class="nav-text">try…catch finally</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%80%E8%88%AC%E6%A0%BC%E5%BC%8F"><span class="nav-number">15.1.</span> <span class="nav-text">异常处理一般格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">16.</span> <span class="nav-text">包装类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">17.</span> <span class="nav-text">类的静态成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="nav-number">18.</span> <span class="nav-text">初始值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DBMS"><span class="nav-number">19.</span> <span class="nav-text">DBMS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">20.</span> <span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9D%83%E9%99%90"><span class="nav-number">21.</span> <span class="nav-text">访问修饰符权限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6"><span class="nav-number">22.</span> <span class="nav-text">文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#abstract-class%E5%92%8Cinterface"><span class="nav-number">23.</span> <span class="nav-text">abstract class 和 interface</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#System-out-println"><span class="nav-number">24.</span> <span class="nav-text">System.out.println()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getDeclaredMethods%E4%B8%8EgetMethods"><span class="nav-number">25.</span> <span class="nav-text">getDeclaredMethods 与 getMethods</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">26.</span> <span class="nav-text">Java 程序初始化的执行顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E5%AD%97%E8%8A%82%E6%B5%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">27.</span> <span class="nav-text">编码字节流转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Servlet"><span class="nav-number">28.</span> <span class="nav-text">Servlet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket"><span class="nav-number">29.</span> <span class="nav-text">socket</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#throw%E4%B8%8Ethrows"><span class="nav-number">30.</span> <span class="nav-text">throw 与 throws</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON"><span class="nav-number">31.</span> <span class="nav-text">JSON</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unicode"><span class="nav-number">32.</span> <span class="nav-text">Unicode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-number">33.</span> <span class="nav-text">类的加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">34.</span> <span class="nav-text">final 关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">35.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="nav-number">36.</span> <span class="nav-text">包与基本功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E5%8E%9F%E5%88%99"><span class="nav-number">37.</span> <span class="nav-text">重写原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%B1%BB"><span class="nav-number">38.</span> <span class="nav-text">文件和类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ResultSet"><span class="nav-number">39.</span> <span class="nav-text">ResultSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSP"><span class="nav-number">40.</span> <span class="nav-text">JSP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">41.</span> <span class="nav-text">运算符优先级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL%E6%89%A7%E8%A1%8C"><span class="nav-number"></span> <span class="nav-text">SQL 执行</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#InterruptedException"><span class="nav-number"></span> <span class="nav-text">InterruptedException</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99"><span class="nav-number"></span> <span class="nav-text">重载与重写</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#super%E4%B8%8Ethis%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number"></span> <span class="nav-text">super 与 this 关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB-1"><span class="nav-number"></span> <span class="nav-text">包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">代码题</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LemonNeko</p>
  <div class="site-description" itemprop="description">「 将生活带给你的如柠檬的酸楚 酿成犹如柠檬汽水味般的甘甜 」</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmxlbW9ubmVrb0BxcS5jb20=" title="E-Mail → mailto:lemonneko@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>



      </section>
        <div class="back-to-top animated">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xlbW9uTmVrbw==" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.lemonneko.cn/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LemonNeko">
      <meta itemprop="description" content="「 将生活带给你的如柠檬的酸楚 酿成犹如柠檬汽水味般的甘甜 」">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LemonNeko的博客">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          牛客网刷题笔记 ——Java
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-10 01:02:08" itemprop="dateCreated datePublished" datetime="2019-03-10T01:02:08+08:00">2019-03-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-08-26 23:24:27" itemprop="dateModified" datetime="2020-08-26T23:24:27+08:00">2020-08-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span id="/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Java/" class="post-meta-item leancloud_visitors" data-flag-title="牛客网刷题笔记 ——Java" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Java/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Java/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><ul>
<li>依赖注入的动机就是<strong>减少</strong>组件之间的<strong>耦合度</strong>，使开发更为简洁</li>
<li>依赖注入能够独立开发各组件，然后根据组件间关系进行组装</li>
<li>依赖注入提供使用<strong>接口编程</strong></li>
<li>依赖注入只对象在使用时<strong>动态注入</strong></li>
</ul>
<a id="more"></a>

<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>创建并启动线程的过程为：<strong>定义线程 —&gt; 实例化线程 —&gt; 启动线程</strong>。</p>
<ol>
<li><p><strong>定义线程：</strong> </p>
<ol>
<li>扩展 <code>java.lang.Thread</code> 类。</li>
<li>实现 <code>java.lang.Runnable</code> 接口。</li>
</ol>
</li>
<li><p><strong>实例化线程：</strong> </p>
<ol>
<li><p>如果是扩展 <code>java.lang.Thread</code> 类的线程，则直接 <code>new</code> 即可。</p>
</li>
<li><p>如果是实现了 <code>java.lang.Runnable</code> 接口的类，则用 <code>Thread</code> 的构造方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread(Runnable target) </span><br><span class="line">Thread(Runnable target, String name) </span><br><span class="line">Thread(ThreadGroup group, Runnable target) </span><br><span class="line">Thread(ThreadGroup group, Runnable target, String name) </span><br><span class="line">Thread(ThreadGroup group, Runnable target, String name, <span class="keyword">long</span> stackSize)</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
</li>
<li><p><strong>启动线程：</strong> </p>
<p>在线程的 Thread 对象上调用 <code>start()</code> 方法，而不是 <code>run()</code> 或者别的方法。</p>
</li>
</ol>
<ul>
<li>启动线程方法 <code>start()</code>  ，线程 <strong><code>stop()</code> 方法已经被弃用</strong>；<strong>守护线程在非守护线程结束后，会自动结束</strong>；等待其他线程通知方法是 wait ()</li>
<li> 对于<strong>线程</strong>而言，<strong>start 是让线程从 new 变成 runnable。run 方法才是执行体的入口</strong>。</li>
<li>可以直接调用 run 方法， 但就起不到多线程的目的了。</li>
<li><code>ThreadLocal</code> 存放的<strong>值是线程内共享的，线程间是互斥的</strong>，主要用于线程内共享一些数据，避免通过参数来传递</li>
<li>要写一个线程类<ul>
<li>可以继承 <code>Thread</code> 方法，然后 override 他的 <code>run()</code> 方法</li>
<li>另一种方法是实现 <code>Runable</code> 接口，即为实现 <code>run()</code> 方法。</li>
</ul>
</li>
</ul>
<h2 id="Collection与Map"><a href="#Collection与Map" class="headerlink" title="Collection与Map"></a>Collection 与 Map</h2><ul>
<li>Collection<ul>
<li>List    有序可重复<ul>
<li> LinkedList        非同步    增、删</li>
<li> ArrayList          非同步     改、查</li>
<li> Vector               同步<ul>
<li> Stack</li>
</ul>
</li>
</ul>
</li>
<li>Set     无序不重复<ul>
<li> HashSet    无序<ul>
<li> LinkedHashSet    保持顺序</li>
</ul>
</li>
<li> TreeSet     需要排序</li>
</ul>
</li>
</ul>
</li>
<li> Map<ul>
<li>HashMap    非同步    无序<ul>
<li> LinkedHashMap    保持顺序</li>
</ul>
</li>
<li> TreeMap     非同步    排序</li>
<li> HashTable   同步，实现一个 key-value 映射的哈希表</li>
<li> WeakHashMap    改进的 HashMap，实现了 “弱引用”，如果一个可以不被引用，则被 GC 回收</li>
</ul>
</li>
</ul>
<p><img src="https://lemonneko-1253391789.cos.ap-shanghai.myqcloud.com/hexo/TheProblemSovingNotesBasedNowcoder/CollectionsFramework.gif" alt="Java集合框架图"></p>
<h2 id="HashMap、HashTable和treeMap"><a href="#HashMap、HashTable和treeMap" class="headerlink" title="HashMap、HashTable和treeMap"></a>HashMap、HashTable 和 treeMap</h2><ul>
<li><p>HashMap</p>
<ul>
<li>HashMap 实际上是一个 “<strong>链表散列</strong>” 的数据结构，即<strong>数组和链表的结合体</strong>。<strong>HashMap 的底层结构是一个数组，数组中的每一项是一条链表</strong>。</li>
<li>HashMap 的实例有俩个参数影响其性能： <strong>初始容量</strong>和 <strong>装填因子</strong>。</li>
<li>HashMap 实现不同步，<strong>线程不安全</strong>。HashTable 线程安全</li>
<li> HashMap 中的 key-value 都是存储在 Entry 中的。</li>
<li><strong>HashMap 可以存 null 键和 null 值</strong>，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过 <code>hashCode()</code> 方法和 <code>equals()</code> 方法保证键的唯一性</li>
<li>解决冲突主要有三种方法：定址法，拉链法，再散列法。<strong>HashMap 是采用拉链法解决哈希冲突的</strong>。<ul>
<li><strong>链表法</strong>是将<strong>相同 hash 值</strong>的对象组成一个链表放在 hash 值对应的槽位；</li>
<li><strong>开放定址法</strong>解决冲突的做法是：当冲突发生时，使用某种探查 (亦称探测) 技术在<strong>散列表</strong>中形成一个<strong>探查 (测) 序列</strong>。 沿此序列逐个单元地查找，直到找到给定的<strong>关键字</strong>，或者碰到一个 ** 开放的地址 (即该地址单元为空)** 为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。</li>
<li><strong>拉链法</strong>解决冲突的做法是： 将所有<strong>关键字为同义词</strong>的结点链接在同一个<strong>单链表</strong>中 。若选定的<strong>散列表长度为 m</strong>，则可将散列表定义为一个由 <strong>m 个头指针</strong>组成的指针数组 T [0..m-1]。凡是散列地址为 i 的结点，均插入到以 T [i] 为头指针的单链表中。T 中各分量的初值均应为空指针。在拉链法中，<strong>装填因子 α 可以大于 1，但一般均取 α≤1</strong>。<strong>拉链法适用于经常进行插入和删除的情况。</strong></li>
</ul>
</li>
</ul>
<p><strong>Map 集合的遍历</strong></p>
<ul>
<li><p>通过<strong>内部类 Entry</strong> 进行遍历</p>
</li>
<li><p>通过<strong>迭代器</strong>进行遍历，先获得 Entry 的 Set 集合</p>
</li>
<li><p>通过 <strong>keySet 方法</strong>获得键的 Set 集合，通过遍历键取值</p>
</li>
<li><p>通过 **map.values ()** 获得所有值，但是不能获得键</p>
<ul>
<li><p>HashTable 和 HashMap 的区别</p>
<ul>
<li><p><strong>继承不同</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span> <span class="keyword">extends</span> <span class="title">Dictionary</span> <span class="keyword">implements</span> <span class="title">Map</span></span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span> <span class="keyword">extends</span>  <span class="title">AbstractMap</span> <span class="keyword">implements</span> <span class="title">Map</span></span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>Hashtable</strong> 中的方法是<strong>同步</strong>的，而 <strong>HashMap</strong> 中的方法在缺省情况下是<strong>非同步</strong>的。在<strong>多线程并发</strong>的环境下，可以<strong>直接使用 Hashtable</strong>，但是要<strong>使用 HashMap</strong> 的话就要自己<strong>增加同步处理</strong>了。</p>
</li>
<li><p><strong>Hashtable</strong> 中， <code>key</code> 和 <code>value</code> 都<strong>不允许出现 null 值</strong>。 在 <strong>HashMap</strong> 中， <code>null</code>  可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为  <code>null</code> 。当 <code>get()</code> 方法返回 null 值时，即可以表示 HashMap 中没有该键，也可以表示该键所对应的值为 <code>null</code> 。因此，<strong>在 HashMap 中不能由 <code>get()</code> 方法来判断 HashMap 中是否存在某个键， 而应该用 <code>containsKey()</code> 方法来判断</strong>。</p>
</li>
<li><p>两个<strong>遍历方式</strong>的内部实现上不同。Hashtable、HashMap 都使用了 <code>Iterator</code>。而由于历史原因，<strong>Hashtable 还使用了 <code>Enumeration</code> 的方式</strong> 。</p>
</li>
<li><p><strong>哈希值的使用不同</strong>，<strong>HashTable 直接使用对象的 hashCode</strong>。而 <strong>HashMap 重新计算</strong> hash 值。</p>
</li>
<li><p>Hashtable 和 HashMap 它们两个内部实现方式的<strong>数组的初始大小和扩容的方式</strong>。HashTable 中 hash 数组默认大小是 11，增加的方式是 old*2+1。HashMap 中 hash 数组的<strong>默认大小是 16</strong>，而且<strong>一定是 2 的指数</strong>。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li><strong>HashSet 子类</strong>依靠 <code>hashCode()</code> 和 <code>equal()</code> 方法来<strong>区分重复元素</strong>。</li>
<li><strong>HashSet</strong> 内部使用 <code>Map</code> 保存数据，即将 HashSet 的数据作为 Map 的 key 值保存，这也是 HashSet 中元素不能重复的原因。而 Map 中保存 key 值的，会去判断当前 Map 中是否含有该 Key 对象，内部是<strong>先通过 key 的 <code>hashCode</code></strong>, <strong>确定有相同的 hashCode 之后，再通过 <code>equals</code> 方法判断是否相同。</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>TreeMap</strong></p>
<p>基于<strong>红黑树</strong>（Red-Black tree）的 <code>NavigableMap</code> 实现。该映射根据其<strong>键的自然顺序</strong>进行排序，或者根据创建映射时提供的 **<code>Comparator</code>** 进行排序，具体取决于使用的构造方法。</p>
<ul>
<li>是一个有序的 key-value 集合，它是通过红黑树实现的</li>
</ul>
</li>
</ul>
<ul>
<li>继承于 AbstractMap，所以它是一个 Map，即一个 key-value 集合<ul>
<li>实现了 NavigableMap 接口，意味着它支持一系列的导航方法，比如返回有序的 key 集合</li>
<li>实现了 Cloneable 接口，意味着它能被克隆</li>
<li>实现了 Java.io.Serializable 接口，意味着它支持序列化</li>
</ul>
</li>
</ul>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>同步是害怕在操作过程的时候被其他线程也进行读取操作，一旦是原子性的操作就不会发生这种情况。</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile 关键字</h2><p>出于<strong>运行速率</strong>的考虑，java 编译器会把<strong>经常经常访问的变量放到缓存</strong>（严格讲应该是<strong>工作内存</strong>）中，读取变量则从缓存中读。但是在<strong>多线程编程</strong>中，<strong>内存中的值</strong>和<strong>缓存中的值</strong>可能会出现不一致。<code>volatile</code> 用于<strong>限定变量只能从内存中读取</strong>，保证对所有线程而言，<strong>值都是一致的</strong>。但是 <strong>volatile 不能保证原子性，也就不能保证线程安全。</strong></p>
<ul>
<li>volatile 关键字用在多线程同步中，可保证读取的可见性</li>
<li> JVM 保证从主内存加载到线程工作内存的值是最新的</li>
<li> volatile 能禁止进行指令重排序</li>
</ul>
<h2 id="synchronized与volatile"><a href="#synchronized与volatile" class="headerlink" title="synchronized与volatile"></a>synchronized 与 volatile</h2><p><strong>synchronized</strong> 很强大，既可以保证<strong>可见性</strong>，又可以保证<strong>原子性</strong>，而 volatile 不能保证原子性！</p>
<p><strong>更多关于 <code>volatile</code> 关键字，这篇博客不错</strong><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pidzE4Mjk3Nzg2Njk4L2FydGljbGUvZGV0YWlscy81MzQyMDc4MA==">从 volatile 说到，i++ 原子操作，线程安全问题<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举类在后台实现时，实际上是转化为一个继承了 <code>java.lang.Enum</code> 类的实体类，原先的枚举类型变成对应的实体类型，枚举类型中的枚举值都会对应调用一次构造函数</p>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><ul>
<li><p><strong>虚拟机栈区</strong></p>
<p>也就是我们常说的栈区，<strong>线程私有</strong>，存放<strong>基本类型，对象的引用和 returnAddress **，在</strong>编译期间 ** 完成分配。</p>
</li>
<li><p><strong>堆区</strong></p>
<p>JAVA 堆，也称 GC 堆，所有<strong>线程共享</strong>，存放<strong>对象的实例和数组</strong>， JAVA 堆是垃圾收集器管理的主要区域。</p>
</li>
<li><p><strong>方法区</strong></p>
<p>所有<strong>线程共享</strong>，存储<strong>已被虚拟机加载的类信息，常量，静态变量</strong>，即时编译器<strong>编译后</strong>的代码等数据。这个区域的<strong>内存回收目标</strong>主要是针对<strong>常量池的对象的回收和对类型的卸载</strong>。</p>
</li>
<li><p>程序计数器</p>
<p><strong>线程私有</strong>，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址</p>
</li>
</ul>
<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>静态变量<strong>只能在类主体中定义</strong>，<strong>不能在方法中定义</strong>。静态变量属于类所有而不适于方法</p>
<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>推荐博客：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2p0YWlnd2gvcC82NjM1NDg0Lmh0bWw=">深入浅出 GC 自动回收机制<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><ul>
<li><p>permantspace (持久带)</p>
<p>主要存档静态类型数据，如 Java Class, Methos 等，与垃圾收集器要收集的 Java 对象关系不大</p>
</li>
<li><p>heapspace</p>
<ul>
<li><p>年轻带和年老带</p>
<p>年轻带的垃圾回收叫 Young GC , 年老带的垃圾回收叫 Full GC .</p>
<p>在年轻带经历了 N 次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为<strong>年老代中存放的都是一些生命周期较长的对象</strong></p>
<p><strong>年老代溢出</strong>原因</p>
<ul>
<li>循环上万次的字符串处理</li>
</ul>
</li>
</ul>
<ul>
<li><p>创建上千万个对象</p>
<ul>
<li>在一段代码内申请上百 M 甚至上 G 的内存</li>
</ul>
<p><strong>持久代溢出</strong>原因</p>
<ul>
<li>动态加载了大量 Java 类而导致溢出</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Java编译和运行命令"><a href="#Java编译和运行命令" class="headerlink" title="Java编译和运行命令"></a>Java 编译和运行命令</h2><ul>
<li><code>java + 你的Java程序</code>的名字但是<strong>不加后缀</strong></li>
<li><code>javac</code> 是编译命令，后跟 <strong>你的 Java 程序名字加后缀</strong>，也就是 <strong>YourClassName.java</strong> </li>
<li>JVM （Java 虚拟机）运行的<strong>是编译后的字节码文件（以.class 为后缀的文件）</strong>，也就是 <strong>YourClassName.class</strong></li>
</ul>
<h3 id="exe"><a href="#exe" class="headerlink" title=".exe"></a>.exe</h3><ul>
<li><p>javac.exe 是编译.java 文件</p>
</li>
<li><p>java.exe 是执行编译好的.class 文件</p>
</li>
<li><p>javadoc.exe 是生成 Java 说明文档</p>
</li>
<li><p>jdb.exe 是 Java 调试器</p>
</li>
<li><p>javaprof.exe 是剖析工具</p>
</li>
</ul>
<h2 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h2><p><code>substring</code> 的源代码其实也是 new 一个 string 对象返回</p>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>switch 语句后的控制表达式只能是 short、char、int、long 整数类型和枚举类型，<strong>不能是 float，double 和 boolean 类型</strong>。<strong>String 类型是 java7 开始支持</strong></p>
<h2 id="try…catch-finally"><a href="#try…catch-finally" class="headerlink" title="try…catch finally"></a>try…catch finally</h2><h3 id="异常处理一般格式"><a href="#异常处理一般格式" class="headerlink" title="异常处理一般格式"></a>异常处理一般格式</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>{</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">}<span class="keyword">catch</span>(异常类型，例如：Exception e){</span><br><span class="line">    <span class="comment">//需要抛出的异常，例如：e.printStackTrace();</span></span><br><span class="line">}<span class="keyword">catch</span>(异常类型){</span><br><span class="line">    <span class="comment">//需要抛出的异常</span></span><br><span class="line">}<span class="keyword">finally</span>{</span><br><span class="line">    <span class="comment">//必定执行的代码块</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在一个异常处理中 catch 语句块是可以多个的，也就是可以抛出多个异常！</p>
<ol>
<li><p><strong>必须在 try 之后添加 catch 或 finally 块</strong>。try 块后可同时接 catch 和 finally 块，但至少有一个块。</p>
</li>
<li><p>必须遵循块顺序：若代码同时使用 catch 和 finally 块，则必须将 catch 块放在 try 块之后。</p>
</li>
<li><p>catch 块与相应的异常类的类型相关。 </p>
</li>
<li><p><strong>一个 try 块可能有多个 catch 块</strong>。若如此，则执行第一个匹配块。即 Java 虚拟机会把实际抛出的异常对象依次和各个 catch 代码块声明的异常类型匹配，如果异常对象为某个异常类型或 其子类的实例，就执行这个 catch 代码块，不会再执行其他的 catch 代码块 。</p>
</li>
<li><p><strong>可嵌套</strong> try-catch-finally 结构。</p>
</li>
<li><p>在 try-catch-finally 结构中，可重新抛出异常。 </p>
</li>
<li><p>除了下列情况，总将执行 finally 做为结束： JVM 过早终止（调用 System.exit (int)）；在 finally 块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击</p>
</li>
</ol>
<p>由此可以看出，<strong>catch 只会匹配一个，因为只要匹配了一个，虚拟机就会使整个语句退出</strong></p>
<p><strong>一旦在 finally 块中使用了 return 或 throw 语句，将会导致 try 块，catch 块中的 return，throw 语句失效</strong></p>
<ol>
<li><p>情况一</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>{}<span class="keyword">catch</span>(){}<span class="keyword">finally</span> <span class="keyword">return</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>程序按顺序执行</p>
</li>
<li><p>情况二</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>{<span class="keyword">return</span>;}<span class="keyword">catch</span>(){} <span class="keyword">finally</span>{} <span class="keyword">return</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>finally 块之后的语句 return 不执行，因为程序在 try 中已经 return</p>
</li>
<li><p>情况三</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>{ } <span class="keyword">catch</span>(){<span class="keyword">return</span>;} <span class="keyword">finally</span>{} <span class="keyword">return</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>程序先执行 try，如果遇到异常执行 catch 块</p>
<ul>
<li><p>有异常</p>
<p>执行 finally 语句中全部代码，<br>最后执行 catch 块中 return 返回。 finally 块后的 return 语句不再执行。</p>
</li>
<li><p>无异常</p>
<p>执行完 try 再 finally 再 return</p>
</li>
</ul>
</li>
<li><p>情况四</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>{ <span class="keyword">return</span>; }<span class="keyword">catch</span>(){} <span class="keyword">finally</span>{<span class="keyword">return</span>;}</span><br></pre></td></tr></tbody></table></figure>

<p>执行 try 块 return 语句（包括 return 语句中的表达式运算），但不返回；<br>再执行 finally 块，<br>执行 finally 块，有 return，从这里返回。<br>此时 finally 块的 return 值，就是代码执行完后的值</p>
</li>
<li><p>情况五</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>{} <span class="keyword">catch</span>(){<span class="keyword">return</span>;}<span class="keyword">finally</span>{<span class="keyword">return</span>;}</span><br></pre></td></tr></tbody></table></figure>

<p>程序执行 catch 块中 return 语句（包括 return 语句中的表达式运算），但不返回；<br>再执行 finally 块，<br>执行 finally 块，有 return，从这里返回。</p>
</li>
<li><p>情况六</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>{ <span class="keyword">return</span>;}<span class="keyword">catch</span>(){<span class="keyword">return</span>;} <span class="keyword">finally</span>{<span class="keyword">return</span>;}</span><br></pre></td></tr></tbody></table></figure>

<p>程序执行 try 块中 return 语句（包括 return 语句中的表达式运算），但不返回</p>
<ul>
<li><p>有异常</p>
<p>执行 catch 块中 return 语句（包括 return 语句中的表达式运算），但不返回；<br>再执行 finally 块<br>执行 finally 块，有 return，从这里返回。</p>
</li>
<li><p>无异常</p>
<p>执行 finally 块，有 return，从这里返回。</p>
</li>
</ul>
</li>
</ol>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>Byte, Short, Integer, Long, Character 这 5 种整型的包装类也只是在对应值<strong>小于等于 127</strong> 并且<strong>大于等于 - 128</strong> 时才可使用常量池，因为他们只占用一个字节 (-128~127);</p>
<p><code>Integer.valueOf</code> 方法中也有判断，如果传递的整型变量<strong>大于等于 - 128</strong> 并且<strong>小于 127</strong> 时会返回 <code>IntegerCache</code> 类中一个静态数组中的某一个对象， 否则会返回一个新的 <code>Integer</code> 对象，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">         </span><br><span class="line">        Integer a = <span class="number">127</span>;</span><br><span class="line">        Integer b = <span class="number">127</span>;</span><br><span class="line">         </span><br><span class="line">        Integer c = <span class="number">128</span>;</span><br><span class="line">        Integer d = <span class="number">128</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(a == b);		<span class="comment">//true</span></span><br><span class="line">        System.out.println(c == d);		<span class="comment">//false</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i01=<span class="number">59</span>;</span><br><span class="line"><span class="keyword">int</span> i02=<span class="number">59</span>;</span><br><span class="line">Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">Integer i04=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>由于 59 在 - 128~127 范围之内，所以在自动装箱的时候，会返回 IntegerCache [59 - (-128)];</li>
<li></li>
<li> 同第一行</li>
<li>因为有 <code>new</code> 关键字，所以在 <code>heap</code> 中开辟了一块新内存放置值为 59 的 Integer 对象。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(i01==i02);<span class="comment">//正确</span></span><br><span class="line">System.out.println(i01==i03);<span class="comment">//正确，都指向IntegerCache[59-(-128)]对象</span></span><br><span class="line">System.out.println(i03==i04);<span class="comment">//错误，引用指向的对象地址不同</span></span><br><span class="line">System.out.println(i02==i04);<span class="comment">//正确</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><ol>
<li>类的静态成员<strong>与类直接相关，与对象无关</strong>，在一个类的所有实例之间共享同一个静态成员</li>
<li>静态成员函数中不能调用非静态成员</li>
<li>非静态成员函数中可以调用静态成员</li>
<li>常量成员才不能修改，<strong>静态成员变量必须初始化，但可以修改</strong>（例如我们常利用静态成员变量统计某个函数的调用次数）</li>
</ol>
<h2 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h2><ul>
<li><strong>类</strong>中声明的变量<strong>有默认初始值</strong>；</li>
<li><strong>方法</strong>中声明的变量<strong>没有默认初始值</strong>，必须在定义时<strong>初始化</strong>，否则在访问该变量时会出错</li>
</ul>
<p><img src="https://lemonneko-1253391789.cos.ap-shanghai.myqcloud.com/hexo/TheProblemSovingNotesBasedNowcoder/DataTypeAndInitialValue.png" alt="数据类型与初始值"></p>
<h2 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a>DBMS</h2><ol>
<li><p><strong>原子性 (Atomic)</strong></p>
<ul>
<li><p><strong>事务被视为不可分割的最小单元</strong>，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p>回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
</li>
<li><p>事务管理子系统</p>
</li>
</ul>
</li>
<li><p><strong>一致性 (Consistency)</strong></p>
<ul>
<li>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
<li>完整性管理子系统</li>
</ul>
</li>
<li><p><strong>隔离性 (Isolation)</strong></p>
<ul>
<li>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
<li>并发控制子系统</li>
</ul>
</li>
<li><p><strong>持久性 (Durability)</strong></p>
<ul>
<li>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</li>
<li>使用重做日志来保证持久性。</li>
<li>恢复管理子系统<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2></li>
</ul>
</li>
<li><p><strong>静态内部类</strong></p>
<ul>
<li>态内部类本身可以访问外部的静态资源，包括静态私有资源。但是不能访问非静态资源，<strong>可以不依赖外部类实例而实例化。</strong></li>
</ul>
</li>
<li><p><strong>成员内部类</strong></p>
<ul>
<li>成员内部类本身可以访问外部的所有资源，但是<strong>自身不能定义静态资源</strong>，因为其<strong>实例化本身就还依赖着外部类</strong>。</li>
</ul>
</li>
<li><p><strong>局部内部类</strong></p>
<ol>
<li>局部内部类就像一个局部方法，<strong>不能被访问修饰符修饰，也不能被 static 修饰</strong>。</li>
<li>局部内部类只能访问所在代码块或者方法中被定义为 final 的局部变量。</li>
</ol>
</li>
<li><p><strong>匿名内部类：</strong></p>
<ol>
<li>没有类名的内部类，不能使用 class，extends 和 implements，没有构造方法。</li>
<li>多用于 GUI 中的事件处理。</li>
<li><strong>不能定义静态资源</strong>。</li>
<li>只能创建一个匿名内部类实例。</li>
<li>一个匿名内部类一定是在 new 后面的，这个匿名类必须继承一个父类或者实现一个接口。</li>
<li>匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效.</li>
</ol>
</li>
</ol>
<p><img src="https://lemonneko-1253391789.cos.ap-shanghai.myqcloud.com/hexo/TheProblemSovingNotesBasedNowcoder/InnerClass.png" alt="内部类"></p>
<blockquote>
<p>1. 为什么使用内部类？</p>
<p>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，</p>
<p>对于内部类都没有影响</p>
<p>1.1. 使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，使用内部类还能够为我们带来如下特性:</p>
<p>(1)、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</p>
<p>(2)、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</p>
<p>(3)、创建内部类对象的时刻并不依赖于外围类对象的创建。</p>
<p>(4)、内部类并没有令人迷惑的 “is-a” 关系，他就是一个独立的实体。</p>
<p>(5)、内部类提供了更好的封装，除了该外围类，其他类都不能访问。</p>
<p>2. 内部类分类:</p>
<p>(一). <strong>成员内部类</strong>:</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">99</span>;</span><br><span class="line">    String name = <span class="string">"Coco"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>{</span><br><span class="line">        String name = <span class="string">"Jayden"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{</span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.name);	<span class="comment">//Coco</span></span><br><span class="line">            System.out.println(name);				<span class="comment">//Jayden</span></span><br><span class="line">            System.out.println(age);				<span class="comment">//99</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerClass</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">        Inner in = o.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        in.show();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>1.Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，<strong>Inner 类可以使用任意访问控制符</strong>，如 public 、 protected 、 private 等</p>
<p>2.Inner 类中定义的 show () 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性 age</p>
<p>3. 定义了成员内部类后，<strong>必须使用外部类对象来创建内部类对象</strong>，而不能直接去 new 一个内部类对象，即：** <code>内部类 对象名 = 外部类对象.new 内部类()</code>**;</p>
<p>4. 编译上面的程序后，会发现产生了两个 .class 文件: Outer.class,Outer$Inner.class {}</p>
<p>5. <strong>成员内部类中不能存在任何 static 的变量和方法，可以定义常量</strong></p>
<p>​    (1). 因为非静态内部类是要依赖于外部类的实例，而静态变量和方法是不依赖于对象的，仅与类相关，</p>
<p>简而言之：在加载静态域时，根本没有外部类，所在在非静态内部类中不能定义静态域或方法，编译不通过；</p>
<p>非静态内部类的作用域是实例级别</p>
<p>​    (2). 常量是在编译器就确定的，放到所谓的常量池了</p>
<p>★★友情提示:</p>
<p>1. 外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法；</p>
<p>2. 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，</p>
<p>可以使用 this 关键字，如：Outer.this.name</p>
<p>(二). <strong>静态内部类</strong>: <strong>是 static 修饰的内部类</strong></p>
<p>1.** 静态内部类不能直接访问外部类的非静态成员，但可以通过 <code>new 外部类().成员</code> 的方式访问 **</p>
<p>2. 如果外部类的静态成员与内部类的成员名称相同，可通过 <code>类名.静态成员</code> 访问外部类的静态成员；</p>
<p>如果外部类的静态成员与内部类的成员名称不相同，则可通过 “成员名” 直接调用外部类的静态成员</p>
<p>3. 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 <code>内部类 对象名 = new 内部类()</code>;</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">static</span> String name = <span class="string">"Coco"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>{</span><br><span class="line">        String name = <span class="string">"Jayden"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{</span><br><span class="line">            System.out.println(Outer.name);             <span class="comment">//Coco</span></span><br><span class="line">            System.out.println(name);                   <span class="comment">//Jayden</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> Outer().age);        <span class="comment">//99</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">        i.show();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>(三). <strong>方法内部类</strong>：其作用域仅限于方法内，方法外部无法访问该内部类</p>
<p>(1). 局部内部类就像是方法里面的一个局部变量一样，是<strong>不能有 public、protected、private 以及 static 修饰符的</strong></p>
<p>(2). <strong>只能访问方法中定义的 final 类型的局部变量</strong> , 因为:</p>
<p>当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在，</p>
<p>直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量；</p>
<p>==&gt; 使用 final 修饰符不仅会保持对象的引用不会改变，而且编译器还会持续维护这个对象在回调方法中的生命周期.</p>
<p><strong>局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部</strong>，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数；</p>
<p>防止被篡改数据，而导致内部类得到的值不一致</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用的形参为何要为 final???</span></span><br><span class="line"><span class="comment">在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，</span></span><br><span class="line"><span class="comment">也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，</span></span><br><span class="line"><span class="comment">毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解</span></span><br><span class="line"><span class="comment">和不可接受的，所以为了保持参数的一致性，就规定使用 final 来避免形参的不改变</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">25</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">13</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>{</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>{</span><br><span class="line">                System.out.println(<span class="string">"访问外部类:"</span> + a);           <span class="comment">//访问外部类:25</span></span><br><span class="line">                System.out.println(<span class="string">"访问内部类:"</span> + c);           <span class="comment">//访问内部类:2</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">        i.print();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">        o.show();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>(3). 注意：在 JDK8 版本之中，方法内部类中调用方法中的局部变量，可以不需要修饰为 final, 匿名内部类也是一样的，主要是 JDK8 之后增加了 Effectively final 功能</strong></p>
<p><a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html"><strong>http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html</strong></a></p>
<p><strong>反编译 jdk8 编译之后的 class 文件，发现内部类引用外部的局部变量都是 final 修饰的</strong></p>
<p>(四). <strong>匿名内部类</strong>:</p>
<p>(1). 匿名内部类是直接使用 new 来生成一个对象的引用；</p>
<p>(2). 对于匿名内部类的使用它是存在一个缺陷的，就是它<strong>仅能被使用一次</strong>，创建匿名内部类时它会立即创建一个该类的实例，</p>
<p>该类的定义会立即消失，所以匿名内部类是<strong>不能够被重复使用</strong> ;</p>
<p>(3). 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口；</p>
<p>(4). <strong>匿名内部类中是不能定义构造函数的，匿名内部类中不能存在任何的静态成员变量和静态方法；</strong></p>
<p>(5). <strong>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法</strong></p>
<p>(6). 匿名内部类初始化：使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> num,String str2)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass(){</span><br><span class="line">            <span class="keyword">int</span> number = num + <span class="number">3</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>{</span><br><span class="line">                <span class="keyword">return</span> number;</span><br><span class="line">            }</span><br><span class="line">        };        <span class="comment">/* 注意：分号不能省 */</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        OuterClass out = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        InnerClass inner = out.getInnerClass(<span class="number">2</span>, <span class="string">"chenssy"</span>);</span><br><span class="line">        System.out.println(inner.getNumber());                              <span class="comment">//5</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InnerClass</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>引用自<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3Byb2ZpbGUvOTM5MjEz">牛客网 BlueFish<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="访问修饰符权限"><a href="#访问修饰符权限" class="headerlink" title="访问修饰符权限"></a>访问修饰符权限</h2><p>protected 一个特点是只要子类都能访问，不管在不在一个包</p>
<p><strong>public&gt;protected&gt;default (包访问权限)&gt;private</strong>，protected 除了可以被同一包访问，还可以被包外的子类所访问</p>
<table>
<thead>
<tr>
<th></th>
<th>类内部</th>
<th>本包</th>
<th>子类</th>
<th>外部包</th>
</tr>
</thead>
<tbody><tr>
<td> public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>static 修饰符的成员属于类成员，父类字段或方法执行被子类同名字段或方法遮蔽，不能被继承覆盖</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>不论是文本文件还是二进制文件，在计算机中都是以二进制形式存储的，所以都当做<strong>二进制</strong>文件读取。</p>
<h2 id="abstract-class和interface"><a href="#abstract-class和interface" class="headerlink" title="abstract class和interface"></a>abstract class 和 interface</h2><ul>
<li>含有 <code>abstract</code> 修饰符的 class 即为抽象类，<strong>abstract 类不能创建的实例对象</strong>。含有 abstract 方法的类必须定义为 abstract class，abstract class 类中的方法不必是抽象的。abstract class 类中定义抽象方法必须在具体 (Concrete) 子类中实现，所以，<strong>不能有抽象构造方法或抽象静态方法</strong>。如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为 abstract 类型。 </li>
<li><strong>接口（interface）</strong>可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的<strong>方法</strong>定义默认为 <code>public abstract</code> 类型，接口中的<strong>成员变量</strong>类型默认为 <code>public static final</code>。 </li>
<li>下面比较一下两者的语法区别： <ol>
<li><strong>抽象类可以有构造方法，接口中不能有构造方法。</strong> </li>
<li>** 抽象类中可以有普通成员变量，接口中没有普通成员变量 **</li>
<li><strong> 抽象类中可以包含非抽象的普通方法</strong>，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。  </li>
<li>抽象类中的抽象方法的访问类型可以是 public，protected 和（默认类型，虽然 eclipse 下不报错，但应该也不行），但接口中的抽象方法只能是 public 类型的，并且默认即为 public abstract 类型。 </li>
<li>** 抽象类中可以包含静态方法，接口中不能包含静态方法  **</li>
<li><strong> 抽象类和接口中都可以包含静态成员变量</strong>，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是 public static final 类型，并且默认即为 public static final 类型。</li>
<li>一个类可以实现多个接口，但只能继承一个抽象类。  </li>
</ol>
</li>
</ul>
<h2 id="System-out-println"><a href="#System-out-println" class="headerlink" title="System.out.println()"></a>System.out.println()</h2><p>System 是 <code>java.lang</code> 中的一个类，<code>out</code> 是 System 内的一个成员变量，这个变量是一个 <code>java.io.PrintStream</code> 类的对象，<code>println</code> 呢就是一个方法了。</p>
<h2 id="getDeclaredMethods与getMethods"><a href="#getDeclaredMethods与getMethods" class="headerlink" title="getDeclaredMethods与getMethods"></a>getDeclaredMethods 与 getMethods</h2><ul>
<li><p><strong><code>public Method[] getDeclaredMethods()</code>** 返回类或接口声明的所有方法，包括 public, protected, default (package) 访问和 private 方法的 Method 对象，</strong>但不包括继承的方法 **。当然也包括它所实现接口的方法。</p>
</li>
<li><p>**<code>public Method[] getMethods()</code>** 返回类的所有 public 方法，包括其继承类的公用方法，当然也包括它所实现接口的方法。</p>
</li>
</ul>
<h2 id="Java程序初始化的执行顺序"><a href="#Java程序初始化的执行顺序" class="headerlink" title="Java程序初始化的执行顺序"></a>Java 程序初始化的执行顺序</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">父类静态变量/父类静态代码块 --&gt; 子类静态变量/子类静态代码块;</span><br><span class="line">   子类静态变量/子类静态代码块 --&gt; 父类非静态变量/父类非静态代码块;</span><br><span class="line">   父类非静态变量/父类非静态代码块 --&gt; 父类构造方法;</span><br><span class="line">   父类构造方法 --&gt; 子类非静态变量/子类非静态代码块;</span><br><span class="line">   子类非静态变量/子类非静态代码块 --&gt; 子类构造方法;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>并不是静态 **<font color="red"> 块</font><strong>最先初始化，而是静态</strong><font color="red">域</font> **</p>
<p>而静态域中包含静态变量、静态块和静态方法，其中需要初始化的是静态变量和静态块。而他们两个的初始化顺序是靠他们俩的位置决定的！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> B t1 = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> B t2 = <span class="keyword">new</span> B();</span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"构造块"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"静态块"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        B t = <span class="keyword">new</span> B();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>初始化顺序是 t1 t2 静态块 构造块</strong></p>
</li>
</ul>
<h2 id="编码字节流转换"><a href="#编码字节流转换" class="headerlink" title="编码字节流转换"></a>编码字节流转换</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String (<span class="keyword">byte</span>[] bytes, String charsetName)</span><br></pre></td></tr></tbody></table></figure>

<p>通过使用指定的 charset 解码指定的 <code>byte</code> 数组，构造一个新的</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.getBytes(Charset charset)</span><br></pre></td></tr></tbody></table></figure>

<p>使用给定的 charset 将此 String 编码到 <code>byte</code> 序列，并将结果存储到新的 <code>byte</code> 数组</p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p><img src="https://lemonneko-1253391789.cos.ap-shanghai.myqcloud.com/hexo/TheProblemSovingNotesBasedNowcoder/Servlet.png" alt="Servlet"></p>
<p><img src="https://lemonneko-1253391789.cos.ap-shanghai.myqcloud.com/hexo/TheProblemSovingNotesBasedNowcoder/Servlet2.jpg" alt="Servlet"></p>
<p>HttpServlet 容器响应 Web 客户请求流程如下：</p>
<ol>
<li>Web 客户向 Servlet 容器发出 Http 请求；</li>
<li>Servlet 容器解析 Web 客户的 Http 请求；</li>
<li>Servlet 容器创建一个 HttpRequest 对象，在这个对象中封装 Http 请求信息；</li>
<li>Servlet 容器创建一个 HttpResponse 对象；</li>
<li>Servlet 容器调用 HttpServlet 的 service 方法，这个方法中会根据 request 的 Method 来判断具体是执行 doGet 还是 doPost，把 HttpRequest 和 HttpResponse 对象作为 service 方法的参数传给 HttpServlet 对象；</li>
<li>HttpServlet 调用 HttpRequest 的有关方法，获取 HTTP 请求信息；</li>
<li>HttpServlet 调用 HttpResponse 的有关方法，生成响应数据；</li>
<li>Servlet 容器把 HttpServlet 的响应结果传给 Web 客户。</li>
</ol>
<p><em>doGet () 或 doPost () 是创建 HttpServlet 时需要覆盖的方法.</em></p>
<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p><img src="https://lemonneko-1253391789.cos.ap-shanghai.myqcloud.com/hexo%E5%AD%98%E5%82%A8/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Java/socket.png" alt="socket"></p>
<h2 id="throw与throws"><a href="#throw与throws" class="headerlink" title="throw与throws"></a>throw 与 throws</h2><ol>
<li>throws 出现在方法头，throw 出现在方法体</li>
<li><strong> throws 表示出现异常的一种可能性，并不一定会发生异常；throw 则是抛出了异常，执行 throw 则一定抛出了某种异常</strong></li>
<li>两者都是消极的异常处理方式，只是抛出或者可能抛出异常，是不会由函数处理，真正的处理异常由它的上层调用处理</li>
</ol>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON 语法可以表示以下三种类型的值:</p>
<ol>
<li><strong>简单值</strong>：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串，数值，布尔值和 null。</li>
<li><strong>对象</strong>：对象作为一种复杂数据类型，表示的是一组有序的<strong>键值对</strong>。而每组键值对中的值可以是简单值，也可以是复杂数据类型的值。</li>
<li><strong>数组</strong>：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型–简单值，对象或数组。</li>
</ol>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>java 默认的字符集是 Unicode，占<strong>两个字节</strong> byte，一个字节 = 8 比特位 bit，所以每个 Unicode 占用 16 比特位</p>
<h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><ol>
<li><strong>Bootstrap ClassLoader</strong><br>负责加载 <code>$JAVA_HOME中jre/lib/rt.jar</code> 里所有的 class，由 C++ 实现，不是 <code>ClassLoader</code> 子类</li>
<li><strong> Extension ClassLoader</strong><br>负责加载 java 平台中扩展功能的一些 jar 包，包括 <code>$JAVA_HOME中jre/lib/*.jar</code> 或 <code>-Djava.ext.dirs</code> 指定目录下的 jar 包</li>
<li><strong> App ClassLoader</strong><br>负责记载 <code>classpath</code> 中指定的 jar 包及目录中 class</li>
<li>**Custom ClassLoader **<br>属于应用程序根据自身需要自定义的 ClassLoader，如 tomcat、jboss 都会根据 j2ee 规范自行实现 ClassLoader<br>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从 Custom ClassLoader 到 BootStrap ClassLoader 逐层检查，只要某个 classloader 已加载就视为已加载此类，保证此类只所有 ClassLoader 加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</li>
</ol>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final 关键字</h2><p>final 定义的变量，可以在<strong>不是必须要在定义的同时完成初始化，也可以在构造方法中完成初始化</strong>。</p>
<p>final 用于可以声明属性和方法，分别表示<strong>属性的不可变</strong>及<strong>方法的不可覆盖</strong>，<strong>可以被重载和继承</strong>。</p>
<p>final 定义变量，可以用 static 也可以不用</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><table>
<thead>
<tr>
<th>元字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>\</code></td>
<td align="left"><code>将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\\n”匹配\n。“\n”匹配换行符。序列“\\”匹配“\”而“\(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。</code></td>
</tr>
<tr>
<td><code>^</code></td>
<td align="left"><code>匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</code></td>
</tr>
<tr>
<td><code>$</code></td>
<td align="left"><code>匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td align="left"><code>匹配前面的子表达式任意次。例如，zo*能匹配“z”，也能匹配“zo”以及“zoo”。*等价于o{0,}</code></td>
</tr>
<tr>
<td><code>+</code></td>
<td align="left"><code>匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</code></td>
</tr>
<tr>
<td><code>?</code></td>
<td align="left"><code>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</code></td>
</tr>
<tr>
<td><code>{n}</code></td>
<td align="left"><code>n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</code></td>
</tr>
<tr>
<td><code>{n,}</code></td>
<td align="left"><code>n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</code></td>
</tr>
<tr>
<td><code>{n,m}</code></td>
<td align="left"><code>m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</code></td>
</tr>
<tr>
<td><code>?</code></td>
<td align="left"><code>当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多的匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少的匹配“o”，得到结果 ['o', 'o', 'o', 'o']</code></td>
</tr>
<tr>
<td><code>.</code></td>
<td align="left"><code>匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。</code></td>
</tr>
<tr>
<td><code>(pattern)</code></td>
<td align="left"><code>匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。</code></td>
</tr>
<tr>
<td><code>(?:pattern)</code></td>
<td align="left">非获取匹配，匹配 pattern 但不获取匹配结果，不进行存储供以后使用。这在使用或字符 “(|)” 来组合一个模式的各个部分时很有用。例如 “industr (?:y|ies)” 就是一个比 “industry|industries” 更简略的表达式。</td>
</tr>
<tr>
<td><code>(?=pattern)</code></td>
<td align="left">非获取匹配，正向肯定预查，在任何匹配 pattern 的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows (?=95|98|NT|2000)” 能匹配 “Windows2000” 中的 “Windows”，但不能匹配 “Windows3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
</tr>
<tr>
<td><code>(?!pattern)</code></td>
<td align="left">非获取匹配，正向否定预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如 “Windows (?!95|98|NT|2000)” 能匹配 “Windows3.1” 中的 “Windows”，但不能匹配 “Windows2000” 中的 “Windows”。</td>
</tr>
<tr>
<td><code>(?&lt;=pattern)</code></td>
<td align="left">非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000) Windows” 能匹配 “2000Windows” 中的 “Windows”，但不能匹配 “3.1Windows” 中的 “Windows”。</td>
</tr>
<tr>
<td><code>(?&lt;!pattern)</code></td>
<td align="left">非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如 “(?&lt;!95|98|NT|2000) Windows” 能匹配 “3.1Windows” 中的 “Windows”，但不能匹配 “2000Windows” 中的 “Windows”。这个地方不正确，有问题此处用或任意一项都不能超过 2 位，如 “(?&lt;!95|98|NT|20) Windows 正确，“(?&lt;!95|980|NT|20) Windows 报错，若是单独使用则无限制，如 (?&lt;!2000) Windows 正确匹配</td>
</tr>
<tr>
<td> x|y</td>
<td align="left"> 匹配 x 或 y。例如，“z|food” 能匹配 “z” 或 “food”(此处请谨慎)。“[zf] ood” 则匹配 “zood” 或 “food”。</td>
</tr>
<tr>
<td><code>[xyz]</code></td>
<td align="left"><code>字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。</code></td>
</tr>
<tr>
<td><code>[^xyz]</code></td>
<td align="left"><code>负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。</code></td>
</tr>
<tr>
<td><code>[a-z]</code></td>
<td align="left"><code>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身.</code></td>
</tr>
<tr>
<td><code>[^a-z]</code></td>
<td align="left"><code>负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</code></td>
</tr>
<tr>
<td><code>\b</code></td>
<td align="left"><code>匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。</code></td>
</tr>
<tr>
<td><code>\B</code></td>
<td align="left"><code>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</code></td>
</tr>
<tr>
<td><code>\cx</code></td>
<td align="left"><code>匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。</code></td>
</tr>
<tr>
<td><code>\d</code></td>
<td align="left">匹配一个数字字符。等价于 [0-9]。grep 要加上 - P，perl 正则支持</td>
</tr>
<tr>
<td><code>\D</code></td>
<td align="left"><code>匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持</code></td>
</tr>
<tr>
<td><code>\f</code></td>
<td align="left"><code>匹配一个换页符。等价于\x0c和\cL。</code></td>
</tr>
<tr>
<td><code>\n</code></td>
<td align="left"><code>匹配一个换行符。等价于\x0a和\cJ。</code></td>
</tr>
<tr>
<td><code>\r</code></td>
<td align="left"><code>匹配一个回车符。等价于\x0d和\cM。</code></td>
</tr>
<tr>
<td><code>\s</code></td>
<td align="left"><code>匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</code></td>
</tr>
<tr>
<td><code>\S</code></td>
<td align="left"><code>匹配任何可见字符。等价于[^ \f\n\r\t\v]。</code></td>
</tr>
<tr>
<td><code>\t</code></td>
<td align="left"><code>匹配一个制表符。等价于\x09和\cI。</code></td>
</tr>
<tr>
<td><code>\v</code></td>
<td align="left"><code>匹配一个垂直制表符。等价于\x0b和\cK。</code></td>
</tr>
<tr>
<td><code>\w</code></td>
<td align="left"><code>匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的"单词"字符使用Unicode字符集。</code></td>
</tr>
<tr>
<td><code>\W</code></td>
<td align="left"><code>匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</code></td>
</tr>
</tbody></table>
<h2 id="包与基本功能"><a href="#包与基本功能" class="headerlink" title="包与基本功能"></a>包与基本功能</h2><p><code>java.awt</code>: 包含构成抽象窗口工具集的多个类，用来构建和管理应用程序的图形用户界面</p>
<p><code>java.lang</code>: 提供 java 编成语言的程序设计的基础类</p>
<p><code>java.io</code>: 包含提供多种输出输入功能的类，</p>
<p><code>java.net</code>: 包含执行与网络有关的类，如 <code>URL</code>，<code>SCOKET</code>，<code>SEVERSOCKET</code>，</p>
<p><code>java.applet</code>: 包含 java 小应用程序的类</p>
<p><code>java.util</code>: 包含一些实用性的类</p>
<h2 id="重写原则"><a href="#重写原则" class="headerlink" title="重写原则"></a>重写原则</h2><p><strong>两小一大原则</strong></p>
<p>方法名相同，参数类型相同</p>
<p>子类返回类型小于等于父类方法返回类型，</p>
<p>子类抛出异常小于等于父类方法抛出异常，</p>
<p>子类访问权限大于等于父类方法访问权限。</p>
<h2 id="文件和类"><a href="#文件和类" class="headerlink" title="文件和类"></a>文件和类</h2><ol>
<li><p>一个文件中可以有多个 <code>public class</code></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{ <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>即，外部类为 <code>public</code>，还可以有 <code>public</code> 的内部类</p>
</li>
<li><p>一个文件中可以有多个类，可以是多个并列的类，也可以是外部类、内部类结合。</p>
</li>
<li><p>一个类中，可以有多个 <code>main</code> 方法，这是重载，但是 <code>public static void main(String[] args)</code> 的方法只能有一个。</p>
</li>
<li><p>类中可以有 <code>main</code> 方法，也可以没有 <code>main</code> 方法，而有一个 <code>main()</code> 方法的时候，也可以是任意访问权限。因为这个类不一定要执行，可以只是辅助类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>{ <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a><code>ResultSet</code></h2><p>ResultSet 跟普通的数组不同，索引从 1 开始而不是从 0 开始</p>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p><code>init</code> 方法：负责初始化 Servlet 对象。在 Servlet 的整个生命周期类，<code>init()</code> 方法只被调用一次</p>
<p><code>destroy</code> 方法：销毁 Servlet 对象，释放占用的资源，Servlet 要被卸载时调用</p>
<p><code>service</code> 方法：接收请求，返回响应的方法。每次请求都执行一次，该方法被 <code>HttpServlet</code> 封装为 <code>doGet</code> 和 <code>doPost</code> 方法 </p>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p><strong>口诀：淡云一笔安洛三福</strong> 单目 &gt; 算数运算符 &gt; 移位 &gt; 比较 &gt; 按位 &gt; 逻辑 &gt; 三目 &gt; 赋值</p>
<p>单目运算符：+，-，++，–，~</p>
<p>算数运算符：+，-，*，/，%</p>
<p>移位运算符：&lt;&lt;,&gt;&gt;</p>
<p>关系运算符：&gt;,&lt;,&gt;=,&lt;=,==,!=</p>
<p>位运算符：&amp;，|，^,</p>
<p>逻辑运算符：&amp;&amp;，||</p>
<p>三目运算符：表达式 1？表达式 2：表达式 3;</p>
<p>赋值运算符：= 等</p>
<h1 id="SQL执行"><a href="#SQL执行" class="headerlink" title="SQL执行"></a>SQL 执行</h1><p><code>Statement</code> 每次执行 sql 语句，数据库都要执行 sql 语句的编译 ，最好用于仅执行一次查询并返回结果的情形，效率高于 PreparedStatement.</p>
<p>PreparedStatement 是预编译的，使用 PreparedStatement 有几个好处：</p>
<ol>
<li><p>在执行可变参数的一条 SQL 时，PreparedStatement 比 Statement 的效率高，因为 DBMS 预编译一条 SQL 当然会比多次编译一条 SQL 的效率要高。</p>
</li>
<li><p>安全性好，有效防止 Sql 注入等问题。</p>
</li>
<li><p>对于多次重复执行的语句，使用 PreparedStament 效率会更高一点，并且在这种情况下也比较适合使用 batch；</p>
</li>
<li><p>代码的可读性和可维护性。</p>
</li>
</ol>
<p>CallableStatement 接口扩展 PreparedStatement，用来调用存储过程，它提供了对输出和输入 / 输出参数的支持。CallableStatement 接口还具有对 PreparedStatement 接口提供的输入参数的支持。</p>
<h1 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h1><p>抛 InterruptedException 的代表方法有：</p>
<ul>
<li>java.lang.Object 类的 wait 方法</li>
<li> java.lang.Thread 类的 sleep 方法</li>
<li> java.lang.Thread 类的 join 方法</li>
</ul>
<h1 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h1><ul>
<li><p>重载</p>
<p>同名不同参，返回值无关</p>
<ol>
<li><p>必须具有不同的参数列表；</p>
</li>
<li><p>可以有不同的返回类型，只要参数列表不同就可以；</p>
</li>
<li><p>可以有不同的访问修饰符；</p>
</li>
<li><p>可以抛出不同的异常；</p>
</li>
<li><p>方法能够在一个类中或者在一个子类中被重载。</p>
</li>
</ol>
</li>
<li><p>重写</p>
<p>同名同参</p>
<ol>
<li><p>在子类中可以根据需要对从基类中继承来的方法进行重写。</p>
</li>
<li><p>重写的方法和被重写的方法必须具有相同方法名称、参数列表和返回类型。</p>
</li>
<li><p>重写方法不能使用比被重写的方法更严格的访问权限。</p>
</li>
</ol>
</li>
</ul>
<h1 id="super与this关键字"><a href="#super与this关键字" class="headerlink" title="super与this关键字"></a>super 与 this 关键字</h1><p>super 和 this 都只能位于构造器的第一行，而且不能同时使用，这是因为会造成初始化两次，this 用于调用重载的构造器，super 用于调用父类被子类重写的方法</p>
<ol>
<li><p>super () 表示调用父类构造函数、this () 调用自己的构造函数，而自己的构造函数第一行要使用 super () 调用父类的构造函数，所以这俩不能在一个构造函数中会出现重复引用的情况</p>
</li>
<li><p>this () 和 super () 都指的是对象，所以，均不可以在 static 环境中使用。包括：static 变量，static 方法，static 语句块 (里面不能使用非 static 类型的)。</p>
</li>
</ol>
<h1 id="包装类-1"><a href="#包装类-1" class="headerlink" title="包装类"></a>包装类</h1><p>包装类的 “==” 运算在不遇到算术运算的情况下不会自动拆箱</p>
<p>包装类的 equals () 方法不处理数据转型</p>
<h2 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h2><ol>
<li><pre><code class="java">public class Test
{
    private int a=10;
    int b=20;
    static int c=1;
    public static void main(String arg[])
    {
        Test t = new Test();
    }
 }
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   A. t.a	B. <span class="keyword">this</span>.c	C. Test.b	D. Test.c</span><br><span class="line"></span><br><span class="line">   A: 在<span class="keyword">private</span>  修饰不能在外部类中调用，main 方法属于Test类的方法， 所以 对象 t 可以在他自己的类方法中调用它的<span class="keyword">private</span></span><br><span class="line"></span><br><span class="line">   B: <span class="keyword">static</span> 方法中没有<span class="keyword">this</span> 这么一说</span><br><span class="line"></span><br><span class="line">   C: b不是<span class="keyword">static</span>变量</span><br><span class="line"></span><br><span class="line">   D: 合理</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> ```java</span><br><span class="line">   package Wangyi;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">Base</span></span><br><span class="line">   {</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>       {</span><br><span class="line">           System.<span class="keyword">out</span>.println(<span class="string">"Base"</span>);</span><br><span class="line">       } </span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">class</span> <span class="title">Son</span> <span class="title">extends</span> <span class="title">Base</span></span><br><span class="line">   {</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>       {</span><br><span class="line">           System.<span class="keyword">out</span>.println(<span class="string">"Son"</span>);</span><br><span class="line">       }</span><br><span class="line">        </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>       {</span><br><span class="line">           System.<span class="keyword">out</span>.println(<span class="string">"SonB"</span>);</span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test01</span></span><br><span class="line">   {</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line"><span class="function"></span>       {</span><br><span class="line">           Base <span class="keyword">base</span> = <span class="keyword">new</span> Son();</span><br><span class="line">           <span class="keyword">base</span>.method();</span><br><span class="line">           <span class="keyword">base</span>.methodB();</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

A. Base sonB        B. son sonB        C. Base son sonB        D. 编译不通过

`Base base=new Son(); `是多态的表示形式。父类对象调用了子类创建了Son对象。

`base`调用的`method()`方法就是调用了子类重写的`method()`方法。

而此时`base`还是属于`Base`对象，`base`调用`methodB()`时`Base`对象里没有这个方法，所以编译不通过。

要想调用的话需要先通过`SON son=(SON)base;`强制转换，然后用`son.methodB()`调用就可以了。</code></pre>
</li>
<li><pre><code class="java">public class Test{
static{
   int x=5;
}
static int x,y;
public static void main(String args[]){
   x--;
   myMethod( );
   System.out.println(x+y+ ++x);
}
public static void myMethod( ){
  y=x++ + ++x;
 }
}
<figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="number">1</span>. 静态语句块中x为局部变量，不影响静态变量x的值</span><br><span class="line"></span><br><span class="line">   <span class="number">2</span>. x和y为静态变量，默认初始值为<span class="number">0</span>，属于当前类，其值得改变会影响整个类运行。</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span>. java中自增操作非原子性的 </span><br><span class="line"></span><br><span class="line">   + main方法中：</span><br><span class="line">     + 执行`x--`后 `x=-<span class="number">1</span>`</span><br><span class="line">     + 调用`myMethod`方法，`x`执行`x++`结果为`-<span class="number">1</span>`(后`++`)，但`x=<span class="number">0</span>`，`++x`结果`1`，`x=<span class="number">1</span>` ，则`y=<span class="number">0</span>`</span><br><span class="line">     + `x+y+ ++x`,先执行`x+y`，结果为`1`，执行`++x`结果为`2`，得到最终结果为`3`</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. ```java</span><br><span class="line">   int a=<span class="number">10</span> <span class="comment">; double b=3.14 ; </span></span><br><span class="line">   //则表达式 'A'+a+b 值的类型		double</span><br></pre></td></tr></tbody></table></figure>

`char` &lt; `short` &lt; `int` &lt; `float` &lt; `double`  不同类型运算结果类型向右边靠齐。</code></pre>
</li>
<li><pre><code class="java">public class Test
{
    public static Test t1 = new Test();
    {
         System.out.println("blockA");
    }
    static
    {
        System.out.println("blockB");
    }
    public static void main(String[] args)
    {
        Test t2 = new Test();
    }
 }
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span>首先，需要明白**类的加载顺序**。</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) 父类静态对象和静态代码块</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 子类静态对象和静态代码块</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>) 父类非静态对象和非静态代码块</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>) 父类构造函数</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>) 子类 非静态对象和非静态代码块</span><br><span class="line"></span><br><span class="line">(<span class="number">6</span>) 子类构造函数</span><br><span class="line"></span><br><span class="line">其中：类中静态块按照声明顺序执行，并且(<span class="number">1</span>)和(<span class="number">2</span>)不需要调用new类实例的时候就执行了(意思就是在类加载到方法区的时候执行的)</span><br><span class="line"><span class="number">2.</span>因而，整体的执行顺序为</span><br><span class="line"></span><br><span class="line"> ```java</span><br><span class="line"><span class="keyword">public</span> static Test  t1 = new Test();         <span class="comment">//(1)</span></span><br><span class="line">static</span><br><span class="line">{</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"blockB"</span>);                <span class="comment">//(2)</span></span><br><span class="line">}</span><br><span class="line">Test t2 =new Test();                             <span class="comment">//(3)</span></span><br></pre></td></tr></tbody></table></figure>

在执行(1)时创建了一个Test对象，在这个过程中会执行非静态代码块和缺省的无参构造函数，在执行非静态代码块时就输出了blockA；然后执行(2)输出blockB；执行(3)的过程同样会执行非静态代码块和缺省的无参构造函数，在执行非静态代码块时输出blockA。因此，最终的结果为

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blockA</span><br><span class="line">blockB</span><br><span class="line">blockA</span><br></pre></td></tr></tbody></table></figure></code></pre>
</li>
<li><pre><code class="java">public static void main(String sgf[]) {

        StringBuffer a=new StringBuffer(“A”);

        StringBuffer b=new StringBuffer(“B”);

        operate(a,b);

        System.out.println(a+”.”+b);
    }
    static void operate(StringBuffer x,StringBuffer y) {
        x.append(y);
        y=x;
    }
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
代码可以编译运行，输出“AB.B”。</code></pre>
<p><img src="https://lemonneko-1253391789.cos.ap-shanghai.myqcloud.com/hexo/TheProblemSovingNotesBasedNowcoder/No6Result.png" alt="结果"></p>
<p>往方法中传参，传的仅仅只是地址，而不是实际内存，所以不要以为 y=x 程序的执行，是 b=a 的执行。这两者是不相等的</p>
</li>
</ol>
<hr>
<p><strong>未完，更新中。。</strong></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/" rel="prev" title="数据库基础">
                  <i class="fa fa-chevron-left"></i> 数据库基础
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/" rel="next" title="爬虫基础">
                  爬虫基础 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-edit"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LemonNeko</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>










<script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            const target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    const { app_id, app_key, server_url } = {"enable":true,"app_id":"u9xtG2j9tl7xlFx5X2liiX9V-MdYXbMMI","app_key":"Q52OfO4yuem0JRQtDjX1Cf2z","server_url":"server.lemonneko.cn","security":true};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.bootcss.com/mathjax/3.0.5/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    new Valine(Object.assign({
      el  : '#valine-comments',
      path: "/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Java/",
    }, {"enable":true,"appId":"u9xtG2j9tl7xlFx5X2liiX9V-MdYXbMMI","appKey":"Q52OfO4yuem0JRQtDjX1Cf2z","placeholder":"Just go go","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":true,"serverURLs":null,"enableQQ":true,"requiredFields":[]}
    ));
  }, window.Valine);
});
</script>

</body>
</html>
